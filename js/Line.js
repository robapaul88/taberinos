/**
 * Line class representing a line segment that can be broken by the ball
 */
class Line {
    constructor(start, end, thickness = 3) {
        this.start = start; // Vector2D
        this.end = end;     // Vector2D
        this.thickness = thickness;
        this.broken = false;
        this.color = '#2c3e50';
        this.brokenColor = '#d5d5d5'; // Light grey, barely visible
        this.isGenerated = false; // Track if this line was generated by white circles
    }

    // Draw the line on the canvas
    draw(ctx) {
        ctx.save();
        ctx.strokeStyle = this.broken ? this.brokenColor : this.color;
        ctx.lineWidth = this.thickness;
        ctx.lineCap = 'round';
        
        if (this.broken) {
            // Draw as dashed line when broken with low opacity
            ctx.setLineDash([3, 6]);
            ctx.globalAlpha = 0.3; // 30% opacity for better visibility
        }

        ctx.beginPath();
        ctx.moveTo(this.start.x, this.start.y);
        ctx.lineTo(this.end.x, this.end.y);
        ctx.stroke();
        ctx.restore();
    }

    // Check if a point (ball) intersects with this line
    intersectsWithPoint(point, radius) {
        if (this.broken) return false;

        // Calculate distance from point to line segment
        const lineVec = Vector2D.fromPoints(this.start, this.end);
        const pointVec = Vector2D.fromPoints(this.start, point);
        
        const lineLength = lineVec.magnitude();
        if (lineLength === 0) return false;

        // Project point onto line
        const projection = pointVec.dot(lineVec) / (lineLength * lineLength);
        
        // Clamp projection to line segment
        const clampedProjection = Math.max(0, Math.min(1, projection));
        
        // Find closest point on line segment
        const closestPoint = this.start.copy()
            .add(lineVec.copy().multiply(clampedProjection));
        
        // Check if distance is within ball radius
        return point.distanceTo(closestPoint) <= radius;
    }

    // Break this line
    break() {
        if (!this.broken) {
            this.broken = true;
            console.log(`Line broken! ${this.isGenerated ? '(Generated line)' : '(Original line)'}`);
        }
    }

    // Check if line is broken
    isBroken() {
        return this.broken;
    }

    // Get the center point of the line
    getCenter() {
        return new Vector2D(
            (this.start.x + this.end.x) / 2,
            (this.start.y + this.end.y) / 2
        );
    }

    // Get the length of the line
    getLength() {
        return this.start.distanceTo(this.end);
    }

    // Get the normal vector of the line (perpendicular)
    getNormal() {
        const lineVec = Vector2D.fromPoints(this.start, this.end);
        return new Vector2D(-lineVec.y, lineVec.x).normalize();
    }

    // Get the closest point on the line to a given point
    getClosestPointTo(point) {
        const lineVec = Vector2D.fromPoints(this.start, this.end);
        const pointVec = Vector2D.fromPoints(this.start, point);
        
        const lineLength = lineVec.magnitude();
        if (lineLength === 0) return this.start.copy();

        // Project point onto line
        const projection = pointVec.dot(lineVec) / (lineLength * lineLength);
        
        // Clamp projection to line segment
        const clampedProjection = Math.max(0, Math.min(1, projection));
        
        // Return closest point on line segment
        return this.start.copy().add(lineVec.copy().multiply(clampedProjection));
    }

    // Check if a point is near an endpoint of the line
    isNearEndpoint(point, threshold = 10) {
        const distToStart = point.distanceTo(this.start);
        const distToEnd = point.distanceTo(this.end);
        
        if (distToStart <= threshold) {
            return { isNear: true, endpoint: 'start', distance: distToStart };
        } else if (distToEnd <= threshold) {
            return { isNear: true, endpoint: 'end', distance: distToEnd };
        }
        
        return { isNear: false, endpoint: null, distance: 0 };
    }

    // Get the direction vector from line endpoints for proper bouncing
    getEndpointNormal(point, endpoint) {
        if (endpoint === 'start') {
            return Vector2D.fromPoints(this.start, point).normalize();
        } else if (endpoint === 'end') {
            return Vector2D.fromPoints(this.end, point).normalize();
        }
        return null;
    }
}
